->POJO - plain old java object
->in Autowired - Field injection is not recommended
-> How Spring Resolve Dependencies?
  1. By Type -> EmailService
  2. If multiple beans -> use name or @Qualifier
  3. If still ambiguous -> use @Primary

-> @RestController
   public class EmployeeController {
       @GetMapping("/employee/{employeeId}") // variable name employeeId should be same here and in the EmployeeDTO argument
       public EmployeeDTO getEmployeeById(@PathVariable Long employeeId){
           return new EmployeeDTO(employeeId, "Abhinav", "abhinav@gmail.com", 30, LocalDate.of(2025, 8, 18), true);

       }
   }
   // Jackson library internally converting the EmployeeDTO object to JSON format
   // if you will go to http://localhost:8080/employee/1997
   //output ={
   //"id": 1997,
   //"name": "Abhinav",
   //"email": "abhinav@gmail.com",
   //"age": 30,
   //"dateOfJoining": "2025-08-18",
   //"active": true
   //}

-> JPA - Before (Java Persistence API), now (Jakarta persistence api)

what is jpa in springboot in simple terms? is it a substitute of database?
Short answer: No. JPA is NOT a database.
If you think it is, thatâ€™s a fundamental misunderstandingâ€”and it will hurt you later.

Now the clean, no-nonsense explanation.

What is JPA (in simple terms)?

JPA = Java Persistence API

It is a set of rules/interfaces that define how Java objects are stored in and read from a database.

Think of JPA as:

A translator between Java objects and database tables

You work with Java objects.
JPA figures out how those map to SQL tables, rows, and columns.

What JPA is NOT

Letâ€™s kill the wrong assumptions directly:

âŒ Not a database
âŒ Not a replacement for MySQL/Postgres/Oracle
âŒ Not something that stores data by itself

You still need a real database.

If the database is gone, JPA is useless.

Then what actually talks to the database?

JPA is just a specification (rules).
You need an implementation.

In Spring Boot, that implementation is usually:

ðŸ‘‰ Hibernate

So the real chain looks like this:

Your Java Code
   â†“
JPA (rules / abstraction)
   â†“
Hibernate (implementation)
   â†“
SQL Queries
   â†“
Database (MySQL, Postgres, etc.)

Why does Spring Boot use JPA at all?

Because writing raw SQL everywhere is painful and error-prone.

Without JPA:

You manually write SQL

Manually map ResultSet â†’ objects

Handle connections, transactions, edge cases

With JPA:

You define a Java class

Annotate it

Done

Example:

@Entity
class User {
  @Id
  Long id;
  String name;
}


Spring + JPA automatically understands:

This is a table

These are columns

How to insert, update, delete, fetch

No SQL required for basic operations.

Is JPA a substitute for SQL?

Partially â€” and only for CRUD.

âœ” Good for:

Simple queries

CRUD operations

Rapid development

âŒ Bad for:

Complex joins

Heavy reporting

Performance-critical queries

Serious applications still use native SQL alongside JPA.

Anyone telling you â€œyou donâ€™t need SQL if you know JPAâ€ is lying or inexperienced.

Final verdict (memorize this)

Database â†’ stores data

JPA â†’ rules for mapping Java objects to database tables

Hibernate â†’ actual engine that runs SQL

Spring Boot â†’ wires everything together

One-line truth:

JPA is an abstraction over SQL, not a substitute for a database.

->  Entity vs DTO
       EmployeeEntity â€” a JPA/persistence object. Annotated with @Entity. Represents how data is stored in the database (id, audit fields, relations, internal fields). Not ideal to return this directly from controllers because it may expose internal details or lazy-loaded associations.
    EmployeeDTO â€” a data transfer object used at the API boundary. Shapes what you accept/return from controllers (validation annotations possible). Keeps internal/persistence concerns separate. You map between DTO and Entity when saving/reading.

   How they might look when printed (JSON returned by a controller)
    EmployeeDTO (what you should return from REST):
    {
        "id": 420,
            "name": "Alice",
            "age": 30
    }
    EmployeeEntity (if serialized directly, may include extra/internal fields):
{
    "id": 420,
        "name": "Alice",
        "age": 30,
        "internalNote": "migrated from legacy system",
        "createdAt": "2025-12-27T10:15:30"
    Summary
    Use Entity for DB operations and DTO for controller input/output.
    Map between them (manually or with a mapper library) to avoid leaking persistence internals

-> Importance of service layer
   The service layer acts as a bridge between the persistence layer(responsible for data access) and the presentation layer(handling user interaction)

   Suppose we have 2 controllers (employee & dept)
   now both these controllers wants to get the data from EmployeeRepository.
   While getting the data we want to log something, authenticate the user. In that case we will be duplicating our code in all the controllers.
   The service layer will come between controllers and Repository.
   The employee Service will tell the controllers that if you want some data from EmployeeRepository, just tell me, I will get the data
   from employeeRepository, add logs, perform auth, and then give you the data.

->     public EmployeeDTO getEmployeeById(Long id) {
           EmployeeEntity employeeEntity = employeeRepository.findById(id).orElse(null);
           ModelMapper mapper = new ModelMapper();
            EmployeeDTO employeeDTO = mapper.map(employeeEntity, EmployeeDTO.class); //mapper.map(source, destinationType)
           return employeeDTO;
           // ModelMapper is used to map the entity to DTO
           // here we are using ModelMapper to map EmployeeEntity to EmployeeDTO
           // we can also do the mapping manually
           // but using ModelMapper is a good practice
           // ModelMapper will go through all the fields of EmployeeEntity and EmployeeDTO
           // and will map the fields with same name and type
           // if the field names are different then we can use @Mapping annotation to map the fields
           // but here the field names are same so we don't need to use @Mapping annotation
           // if any field is missing in EmployeeDTO then it will be ignored
           // if any field is missing in EmployeeEntity then it will be set to null in EmployeeDTO
       }
