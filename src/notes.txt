->POJO - plain old java object
->in Autowired - Field injection is not recommended
-> How Spring Resolve Dependencies?
  1. By Type -> EmailService
  2. If multiple beans -> use name or @Qualifier
  3. If still ambiguous -> use @Primary

-> @RestController
   public class EmployeeController {
       @GetMapping("/employee/{employeeId}") // variable name employeeId should be same here and in the EmployeeDTO argument
       public EmployeeDTO getEmployeeById(@PathVariable Long employeeId){
           return new EmployeeDTO(employeeId, "Abhinav", "abhinav@gmail.com", 30, LocalDate.of(2025, 8, 18), true);

       }
   }
   // Jackson library internally converting the EmployeeDTO object to JSON format
   // if you will go to http://localhost:8080/employee/1997
   //output ={
   //"id": 1997,
   //"name": "Abhinav",
   //"email": "abhinav@gmail.com",
   //"age": 30,
   //"dateOfJoining": "2025-08-18",
   //"active": true
   //}

-> JPA - Before (Java Persistence API), now (Jakarta persistence api)

what is jpa in springboot in simple terms? is it a substitute of database?
Short answer: No. JPA is NOT a database.
If you think it is, that‚Äôs a fundamental misunderstanding‚Äîand it will hurt you later.

Now the clean, no-nonsense explanation.

What is JPA (in simple terms)?

JPA = Java Persistence API

It is a set of rules/interfaces that define how Java objects are stored in and read from a database.

Think of JPA as:

A translator between Java objects and database tables

You work with Java objects.
JPA figures out how those map to SQL tables, rows, and columns.

What JPA is NOT

Let‚Äôs kill the wrong assumptions directly:

‚ùå Not a database
‚ùå Not a replacement for MySQL/Postgres/Oracle
‚ùå Not something that stores data by itself

You still need a real database.

If the database is gone, JPA is useless.

Then what actually talks to the database?

JPA is just a specification (rules).
You need an implementation.

In Spring Boot, that implementation is usually:

üëâ Hibernate

So the real chain looks like this:

Your Java Code
   ‚Üì
JPA (rules / abstraction)
   ‚Üì
Hibernate (implementation)
   ‚Üì
SQL Queries
   ‚Üì
Database (MySQL, Postgres, etc.)

Why does Spring Boot use JPA at all?

Because writing raw SQL everywhere is painful and error-prone.

Without JPA:

You manually write SQL

Manually map ResultSet ‚Üí objects

Handle connections, transactions, edge cases

With JPA:

You define a Java class

Annotate it

Done

Example:

@Entity
class User {
  @Id
  Long id;
  String name;
}


Spring + JPA automatically understands:

This is a table

These are columns

How to insert, update, delete, fetch

No SQL required for basic operations.

Is JPA a substitute for SQL?

Partially ‚Äî and only for CRUD.

‚úî Good for:

Simple queries

CRUD operations

Rapid development

‚ùå Bad for:

Complex joins

Heavy reporting

Performance-critical queries

Serious applications still use native SQL alongside JPA.

Anyone telling you ‚Äúyou don‚Äôt need SQL if you know JPA‚Äù is lying or inexperienced.

Final verdict (memorize this)

Database ‚Üí stores data

JPA ‚Üí rules for mapping Java objects to database tables

Hibernate ‚Üí actual engine that runs SQL

Spring Boot ‚Üí wires everything together

One-line truth:

JPA is an abstraction over SQL, not a substitute for a database.

->  Entity vs DTO
       EmployeeEntity ‚Äî a JPA/persistence object. Annotated with @Entity. Represents how data is stored in the database (id, audit fields, relations, internal fields). Not ideal to return this directly from controllers because it may expose internal details or lazy-loaded associations.
    EmployeeDTO ‚Äî a data transfer object used at the API boundary. Shapes what you accept/return from controllers (validation annotations possible). Keeps internal/persistence concerns separate. You map between DTO and Entity when saving/reading.

   How they might look when printed (JSON returned by a controller)
    EmployeeDTO (what you should return from REST):
    {
        "id": 420,
            "name": "Alice",
            "age": 30
    }
    EmployeeEntity (if serialized directly, may include extra/internal fields):
{
    "id": 420,
        "name": "Alice",
        "age": 30,
        "internalNote": "migrated from legacy system",
        "createdAt": "2025-12-27T10:15:30"
    Summary
    Use Entity for DB operations and DTO for controller input/output.
    Map between them (manually or with a mapper library) to avoid leaking persistence internals

-> Importance of service layer
   The service layer acts as a bridge between the persistence layer(responsible for data access) and the presentation layer(handling user interaction)

   Suppose we have 2 controllers (employee & dept)
   now both these controllers wants to get the data from EmployeeRepository.
   While getting the data we want to log something, authenticate the user. In that case we will be duplicating our code in all the controllers.
   The service layer will come between controllers and Repository.
   The employee Service will tell the controllers that if you want some data from EmployeeRepository, just tell me, I will get the data
   from employeeRepository, add logs, perform auth, and then give you the data.

->     public EmployeeDTO getEmployeeById(Long id) {
           EmployeeEntity employeeEntity = employeeRepository.findById(id).orElse(null);
           ModelMapper mapper = new ModelMapper();
            EmployeeDTO employeeDTO = mapper.map(employeeEntity, EmployeeDTO.class); //mapper.map(source, destinationType)
           return employeeDTO;
           // ModelMapper is used to map the entity to DTO
           // here we are using ModelMapper to map EmployeeEntity to EmployeeDTO
           // we can also do the mapping manually
           // but using ModelMapper is a good practice
           // ModelMapper will go through all the fields of EmployeeEntity and EmployeeDTO
           // and will map the fields with same name and type
           // if the field names are different then we can use @Mapping annotation to map the fields
           // but here the field names are same so we don't need to use @Mapping annotation
           // if any field is missing in EmployeeDTO then it will be ignored
           // if any field is missing in EmployeeEntity then it will be set to null in EmployeeDTO
       }

 -> PUT vs PATCH (HTTP)
    PUT

    Meaning: Replace the entire resource.

    What you send: Full object (even fields that didn‚Äôt change).

    What happens: Server overwrites the existing resource.

    Missing fields: Deleted / reset.

    Idempotent: ‚úÖ Yes (same request ‚Üí same result).

    Example
    PUT /users/1
    {
      "name": "Abhinav",
      "age": 30
    }
If email existed earlier ‚Üí it‚Äôs gone.

PATCH

Meaning: Modify part of the resource.

What you send: Only changed fields.

What happens: Server updates selectively.

Missing fields: Untouched.

Idempotent: ‚ö†Ô∏è Not guaranteed (depends on implementation).

Example
PATCH /users/1
{
  "age": 31
}
Everything else stays exactly the same.


// in the end of this commit
url - http://localhost:8080/employees
type - post
input in postman -
{
    "name": "ui",
    "email": "abhi",
    "age": 2,
    "dateOfJoining": "2025-08-18",
    "isActive": true,
    "role": "USER",
    "salary": 5000.00
}

output -
{
    "message": "input validation failed",
    "status": "400 BAD_REQUEST",
    "subErrors": [
        "Email should be valid",
        "Name must be between 3 and 10 characters",
        "Age should not be less than 18"
    ]
}
